{"name":"Exdi","tagline":"Dependency injection container for JavaScript","body":"exdi [![Build Status](https://travis-ci.org/dariuszp/exdi.png?branch=master)](https://travis-ci.org/dariuszp/exdi)\r\n====\r\n\r\n### Installation\r\n\r\n```JavaScript\r\nnpm install exdi\r\n```\r\n\r\nAfter that, include exdi in Your file:\r\n\r\n```JavaScript\r\nvar exdi = require('exdi');\r\n```\r\n\r\n### Usage\r\n\r\nExdi is a dependency injection container. But whole library is practically a repository of containers.\r\nThere are two ways to create container:\r\n\r\n*Named container:*\r\n\r\n```JavaScript\r\nvar container = exdi.get('myContainer');\r\n```\r\n\r\nThat will create new container and register it under \"myContainer\" name. So each time you ask for myContainer, same instance will be returned.\r\n\r\nOr you can just spawn anonymous container using:\r\n\r\n```JavaScript\r\nvar container = exdi.create();\r\n```\r\n\r\nThis will create unregisted container so there is no way to get it again from inside Exdi.\r\n\r\n### Values and constructors\r\n\r\nBasic feature is to set and create container values. Using our \"container\" variable, we an do this like that:\r\n\r\n```JavaScript\r\ncontainer.set('name', 'Will'); // this will set \"name\" variable with \"Will\" value.\r\ncontainer.set('surname', 'Smith'); // this will set \"surname\"\r\n\r\ncontainer.get('surname'); // this will return \"Smith\"\r\n```\r\n\r\nNow, it would be not much of dependency injection container if we would not be able to build things using dependencies.\r\n\r\n```JavaScript\r\ncontainer.set('FullName', function (name, surname) {\r\n    return name + ' ' + surname;\r\n});\r\n```\r\n\r\nConstrution above will register a constructor. Constructors are executed each time you want to retreive them using .get() method.\r\nSo this code:\r\n\r\n```JavaScript\r\ncontainer.get('FullName');\r\n```\r\n\r\nwill return \"Will Smith\". There are few things to remember:\r\n\r\n* _First capital letter_ is reserverd for constructors. It's _very important_. If key have capital letter as first sign, you can only set a function as value. This way that function will be executed each time you want to retreive it.\r\n* If you would use small letter and call it \"fullName\", code above would return registered function instead of result of that function.\r\n* Look how \"name\" and \"surname\" is handled. Exdi will extract parameters names and match them with container values. So there is no need for You to provide them. Just remember to have them in container before using constructor.\r\n* You can also pass other constructors as parameter. Like this:\r\n\r\n```JavaScript\r\ncontainer.set('age', '27');\r\ncontainer.set('AgeAndFullName', function (age, FullName) {\r\n    return FullName + ', age ' + age;\r\n})\r\n\r\ncontainer.get('AgeAndFullName'); // Will Smith, age 27\r\n```\r\n\r\n#### REMEMBER\r\n\r\nIf you register function like this:\r\n\r\n```JavaScript\r\ncontainer.set('FullName', function (name, surname) {\r\n    return name + ' ' + surname;\r\n});\r\n```\r\n\r\n*container.get('FullName')* will return result of a function since first capital letter means *Constructor*. This follow convention that most JS progremmers use.\r\nSo you will get \"Will Smith\". If you register function like this:\r\n\r\n```JavaScript\r\ncontainer.set('fullName', function (name, surname) {\r\n    return name + ' ' + surname;\r\n});\r\n```\r\n\r\n*container.get('FullName')* will return whole function instead of executing it.\r\n\r\n### Executing any function\r\n\r\nSometimes you will want just execute one of Your functions without registering it in container. You can do it like this:\r\n\r\n```JavaScript\r\nfunction add(x, y) {\r\n    return x + y;\r\n}\r\n\r\ncontainer.set('x', 1);\r\ncontainer.set('y', 2);\r\n\r\ncontainer.execute(add); // this will return 3\r\n```\r\n\r\nAnd sometimes, you will want to overwrite some container values with Yours without changing them in container:\r\n\r\n```JavaScript\r\nfunction add(x, y) {\r\n    return x + y;\r\n}\r\n\r\ncontainer.set('x', 1);\r\ncontainer.set('y', 2);\r\n\r\ncontainer.execute(add, {\r\n    y: 5\r\n}); // this will return 6. x is intact, y is replaced by 5 but only for execution of a function. Container value is intact.\r\n```\r\n\r\nAlso there is a problem of methods. Sometimes you have methods, functions that are part of bigger object and you want\r\nto execute them BUT you don't want to loose object context. In other words, you don't want \"this\" pointing to something\r\nelse than that object. It's also possible like this:\r\n\r\n```JavaScript\r\nvar myObj = {\r\n    this.add = function add(x, y) {\r\n        return x + y + this.z;\r\n    },\r\n    z: 4\r\n}\r\n\r\ncontainer.set('x', 1);\r\ncontainer.set('y', 2);\r\n\r\ncontainer.execute(add, {}, myObj); // this will return 7\r\n```\r\n\r\nAs you see, just provide object as third parameter and it will be used as context of execution.\r\nIf context object is not provided, \"this\" will point to container object. So inside your function\r\nyou can for example call\r\n\r\n```JavaScript\r\nfunction add(x, y) {\r\n    this.get('name'); // Will\r\n    return x + y;\r\n}\r\n```\r\n\r\nAlso, sometimes you want to execute function that is already registered. You can do that using string as first parameter for execute.\r\nExdi will try to find value inside container using that name. Just remember, it must be a function.\r\n\r\n```\r\nfunction add(x, y) {\r\n    this.get('name'); // Will\r\n    return x + y;\r\n}\r\n\r\ncontainer.set('x', 1);\r\ncontainer.set('y', 2);\r\ncontainer.set('add', add);\r\n\r\ncontainer.execute('add');\r\n```\r\n\r\n### Creating objects\r\n\r\nThere is also alternative to .execute() that will execute given function with operator \"new\".\r\n\r\n```JavaScript\r\nvar constructContainer = exdi.create();\r\n    constructContainer.set('px', 1);\r\n    constructContainer.set('py', 2);\r\n\r\nvar c1 = constructContainer.construct(function (px, py) {\r\n    this.x = px * 2;\r\n    this.y = py * 2;\r\n}, { py: 5 });\r\n\r\n    c1.x // 2\r\n    c1.y // 10\r\n```\r\n\r\n### Queue nad Parallel\r\n\r\nSometimes, you need to take control over code execution. It's hard to do since most of the time You will be dealing with\r\nasync functions. For that, Exdi have tools like Queue and Parallel. Both can be created using methods with the same names:\r\n\r\n```JavaScript\r\nvar queue = container.createQueue();\r\n```\r\n\r\nOR\r\n\r\n```JavaScript\r\nvar parallel = container.createParallel();\r\n```\r\n\r\nMain difference between queue and paraller is simple. Queue will execute one function at that time in chain. So\r\nsecond function in queue will be executed ONLY if first one is finished. Library will report when each step is done\r\nand will also report using events that all steps are finished.\r\n\r\nParallel works in simmilar way but all functions will be called at the same time. It's like a \"promise\" pattern.\r\n\r\nTo add function to queue or parallel,, use .add() method:\r\n\r\n```JavaScript\r\nfunction soSomethingCool(x, y, exdiDone) {\r\n    this.get('name'); // Will\r\n    // here some async code\r\n    return x + y;\r\n    exdiDone();\r\n}\r\n\r\nqueue.add(soSomethingCool);\r\nqueue.add(soSomethingCool); // again\r\n// or\r\nparallel.add(soSomethingCool);\r\nparallel.add(soSomethingCool); // again if you want\r\n```\r\n\r\nto run either of them, you can use:\r\n\r\n```JavaScript\r\nqueue.execute(); // will start queue\r\nparallel.execute(); //will start parallel\r\n```\r\n\r\nFunctions passed to queue and parallel are quite different. Notice custom aprameter \"exdiDone\". It's a function that\r\nYou should call when it's finished. Remember we are dealing with async functions. So when you do what You have to do,\r\ncall:\r\n\r\n```JavaScript\r\nexdiDone();\r\n```\r\n\r\nor next function will not be called in Queue and Parallel will never finish. You can register events for both libraries:\r\n\r\n```JavaScript\r\nqueue.on('timeout', function () { /* too long */ }); // called after X seconds\r\n```\r\n\r\nTimeout is fired IF code execution takes too long. You can change default value (0) using *queue.setTimeoutLimit(5);*\r\n\r\nSame way, you can register events for parallel. There are two events available:\r\n\r\n* step\r\n* done\r\n\r\nTo cancel execution of both tools, use:\r\n\r\n```JavaScript\r\nqueue.clearQueue(); // clear queue, function currently in execution will finish but next one will not be fired\r\nparallel.clearTasks(); // function can finish but step and done event wont called\r\n```\r\n\r\n### Minified code\r\n\r\nSometimes, programmers use tools that minify JavaScript code making it unreadable but short and small.\r\nThis will change variable names in Your code. So for example this:\r\n\r\n```JavaScript\r\ncontainer.set('fullName', function (name, surname) {\r\n    return name + ' ' + surname;\r\n});\r\n```\r\n\r\nwill look like this after minification:\r\n\r\n```JavaScript\r\ncontainer.set('fullName', function (a, b) {\r\n    return a + ' ' + b;\r\n});\r\n```\r\n\r\nAs You probably noticed, this will not work anymore. There is no 'a' and 'b' in our container. There is a way to fix that.\r\n\r\nJust pass array first list of keys and function as last argument. This way, container will match function arguments based on\r\norder and values of array keys instead of function arguments. Just like that:\r\n\r\n```JavaScript\r\ncontainer.set('fullName', ['name', 'surname', function (a, b) {\r\n    return a + ' ' + b;\r\n}]);\r\n```\r\n\r\n*IMPORTANT*\r\nLast argument CAN be a string. Just remember that it will be used to extract function from container by given name. Like this:\r\n\r\n```\r\ncontainer.set('concatStrings', function (a, b) {\r\n   return a + ' ' + b;\r\n};\r\ncontainer.set('fullName', ['name', 'surname', 'concatStrings']);\r\n```\r\n\r\nNow Your cod work again.\r\n\r\n## REMEMBER\r\n\r\n* always use small first letter when registering a value\r\n* when you set value with first capital letter, you need to pass function and when You try to retrive that key, function will be executed and result of that function will be returned\r\n* if you register function with small name, code of that function will be returned\r\n* queue will run one function at a time but parallel will start them all at once\r\n* you can pass array with keys and function as last argument to avoid problems with minification\r\n* you can register containers in exdi using .get('name') or create anonymous ones using .create()\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}